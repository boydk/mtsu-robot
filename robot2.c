#pragma config(Sensor, S1,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S2,     HTCOMPASS,      sensorI2CCustom)
#pragma config(Sensor, S3,     LEGOLS,         sensorLightInactive)
#pragma config(Sensor, S4,     sonarSensor,    sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// need to add another touch sensor when we find the dongle
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-compass.h"
#include "drivers/lego-light.h"
#include "drivers/lego-touch.h"

// The sensor is connected to the first port
// of the SMUX which is connected to the NXT port S1.
// To access that sensor, we must use msensor_S1_1.  If the sensor
// were connected to 3rd port of the SMUX connected to the NXT port S4,
// we would use msensor_S4_3

// Give the sensor a nice easy to use name
const tMUXSensor LEGOTOUCHLEFT = msensor_S1_2;
const tMUXSensor LEGOTOUCHRIGHT = msensor_S1_1;

//C:\Program Files\Robomatter Inc\ROBOTC Development Environment\Drivers\rdpartyrobotcdr-3.3.1\drivers

// Ken, Josh, Christie
// Robot 2

// task prototypes

task MoveTowardEgg;
task GrabEgg;
task DetectEgg;
task DetectWall;
task GoToScore;
task PushEggIntoNest();
task InNestWithoutEgg();

// function prototypes

bool isInHomeRange(int value);
bool isOverTape(int value);
bool isFacingOppositeHome(int value);
bool isOnHomeTarget(int value);
void armCheck();
void turnLeft(int speed);
void turnRight(int speed);
void goForward(int speed);
void goBackward(int speed);
void halt();
void openArm(int speed);
void closeArm(int speed);
void haltArm();

// Constants

const int HOME_TARGET = 315; // location sensor value

const int DETECT_EGG_DISTANCE = 30;
const int DETECT_EGG_CLOSE = 10;
// light on
const int LIGHT_SENSOR_BLACK = 35;
// light off
//const int LIGHT_SENSOR_BLACK = 12;

const int ARMS_OPEN = -55;
const int ARMS_CLOSED = 10;
const int ARMS_NORMAL = 0;

// set of speeds to try
const int SPEED_20 = 20;
const int SPEED_30 = 30;
const int SPEED_40 = 40;
const int SPEED_50 = 50;
const int SPEED_60 = 60;
const int SPEED_75 = 75;

const int ARM_SPEED = 15;

// global vars

int CURRENT_SPEED = 0; // will set to consts above

bool detectedEgg = false;

bool eggInLeftHand = false;
bool eggInRightHand = false;

bool hasExitedForFirstTime = false;

bool goingToScore = false;

bool isMovingTowardEgg = false;

bool couldBeInEnemyNest = false;


//==========================================================================================================================================

task Wander()
{
	double randDistance = 0;
	double randTurn = 0;
	int randDirection = 0;

	bool goingForward = false;

  while(true)
  {
  	nxtDisplayCenteredBigTextLine(0, "TASK WAN");     // Display that Main is running.

    wait1Msec(300);                                 // Allow for a short wait, freeing up the CPU for other tasks..

    armCheck();

    // go for longer to get out of base
    if (!hasExitedForFirstTime)
    {
    	ClearTimer(T1);
    	// go forward a large distance
    	while (time1[T1] < 1000)
    	{
    		goForward(SPEED_75);
    	}
    	hasExitedForFirstTime = true;
    	StartTask(InNestWithoutEgg, 10);
    }
    else
  	{
    	if (goingForward)
    	{
		    // go forward random distance (within a range, not too short, but not too long)
		    randDistance = rand() % 800;
		    ClearTimer(T1);
		    while (time1[T1] < randDistance)
		    {
		    	goForward(CURRENT_SPEED);
		    }
		    goingForward = false;
	  	}
			else
			{
		    // calculate random number to turn (within a range, don't want to turn too small or too wide)
				// and rand direction
		    randTurn = rand() % 500;
		    randDirection = rand() % 2;
		    ClearTimer(T1);

		    // make the turn
		    while (time1[T1] < randTurn)
		    {
		    	if (randDirection)
		    	{
		    		turnLeft(CURRENT_SPEED-20);
		    	}
		    	else
		    	{
		    		turnRight(CURRENT_SPEED-20);
		    	}
		    }
		    goingForward = true;
    	}
		}

    // repeat

  }
  return;
}

//==========================================================================================================================================

//==========================================================================================================================================

task DetectEgg()
{
  while(true)
  {

    wait1Msec(300);                                 // Allow for a short wait, freeing up the CPU for other tasks.

    if (SensorValue(sonarSensor) < DETECT_EGG_DISTANCE)
    {
    	StopTask(Wander);

    	halt();

    	nxtDisplayCenteredBigTextLine(0, "TASK DE");     // Display that Main is running.

    	detectedEgg = true;
    	StopTask(Wander);

    	// open arms
    	while (nMotorEncoder[motorA] > ARMS_OPEN)
    	{
    		openArm(ARM_SPEED);
    	}

    	haltArm();

    	EndTimeSlice();
    	StartTask(MoveTowardEgg);
    	StopTask(DetectEgg);
    	break; // passed on to other task, should be restarted when appropriate
    }
  }
  return;
}

//==========================================================================================================================================

//==========================================================================================================================================

task MoveTowardEgg()
{
  while(true)
  {
  	nxtDisplayCenteredBigTextLine(0, "TASK MTE");     // Display that Main is running.

    wait1Msec(300);                                 // Allow for a short wait, freeing up the CPU for other tasks.

    isMovingTowardEgg = true;

    ClearTimer(T3);
    while (SensorValue(sonarSensor) > DETECT_EGG_CLOSE && time1[T3] < 3000)
    {
    	goForward(SPEED_30);
    }

    halt();

		isMovingTowardEgg = false;

    EndTimeSlice();

    StartTask(GrabEgg);
    StopTask(MoveTowardEgg);
    break;
  }
  return;
}

//==========================================================================================================================================


//==========================================================================================================================================

task GrabEgg()
{
  while(true)
  {
  	nxtDisplayCenteredBigTextLine(0, "TASK GRAB");     // Display that Main is running.

    wait1Msec(300);                                 // Allow for a short wait, freeing up the CPU for other tasks.

    ClearTimer(T3);
    eggInRightHand = false;

    if (!eggInRightHand)
    {
    	while (time1[T3] < 1500)
    	{
    		turnLeft(SPEED_20);
			}
			eggInRightHand = true;
    }

    halt();

    while (nMotorEncoder[motorA] < ARMS_CLOSED)
  	{
  		closeArm(ARM_SPEED);
  	}

  	haltArm();

  	goingToScore = true;


    EndTimeSlice();

    StartTask(GoToScore);
    StopTask(GrabEgg);
    break;

  }
  return;
}

//==========================================================================================================================================

//==========================================================================================================================================

task GoToScore()
{
  while(true)
  {
  	nxtDisplayCenteredBigTextLine(0, "TASK SCORE");     // Display that Main is running.

    wait1Msec(300);                                 // Allow for a short wait, freeing up the CPU for other tasks.

    // turn until facing home direction
    //while (HTMCreadRelativeHeading(HTCOMPASS) != 175)
    //while (!(isInHomeRange(HTMCreadRelativeHeading(HTCOMPASS)))
    while (!(isInHomeRange(HTMCreadHeading(HTCOMPASS))))
    {
    	turnLeft(CURRENT_SPEED - 10);
			wait1Msec(300);
    }

    halt();

    wait1Msec(300);

    while (!(isOnHomeTarget(HTMCreadHeading(HTCOMPASS))))
    {
    	turnLeft(CURRENT_SPEED - 30);
			wait1Msec(300);
    }

    halt();

    wait1Msec(300);

    while (!(isOverTape(LSvalNorm(LEGOLS))))
    {
    	// go forward to home
    	goForward(CURRENT_SPEED);
		}

		//then stop
		halt();

		// and start push into nest task
		EndTimeSlice();

		StartTask(PushEggIntoNest);
		StopTask(GoToScore);
		break;

  }
  return;
}

//==========================================================================================================================================

//==========================================================================================================================================

task PushEggIntoNest()
{
  while(true)
  {
  	nxtDisplayCenteredBigTextLine(0, "TASK PUSH");     // Display that Main is running.

    wait1Msec(300);                                 // Allow for a short wait, freeing up the CPU for other tasks.

  	// open arms first
    while (nMotorEncoder[motorA] > ARMS_OPEN)
  	{
  		openArm(ARM_SPEED);
  	}

  	haltArm();

  	wait1Msec(300);

  	// push eggs into nest set distance
  	ClearTimer(T4);
  	// go forward a large distance
  	while (time1[T4] < 800)
  	{
  		goForward(CURRENT_SPEED);
  	}

  	halt();

		wait1Msec(300);

		// then back up into arena again
		ClearTimer(T4);
  	// go backward a large distance
  	while (time1[T4] < 2000)
  	{
  		goBackward(CURRENT_SPEED);
  	}

  	halt();

		eggInRightHand = false;

		wait1Msec(300);

		// then turn around and start detect egg again
		ClearTimer(T4);
  	// turn until compass knows we're facing away from home
  	while (!(isFacingOppositeHome(HTMCreadHeading(HTCOMPASS))))
  	{
  		turnLeft(CURRENT_SPEED);
  	}

  	halt();

		wait1Msec(300);

		/*
		// go forward a bit

		ClearTimer(T4);

  	while (time1[T4] < 400)
  	{
  		goForward(CURRENT_SPEED);
  	}

  	halt();
  	*/

		// then start detect egg task again, wander should still be going at this point

		goingToScore = false;

		EndTimeSlice();

		StartTask(DetectEgg, 5);
		StartTask(Wander, 1);
		StopTask(PushEggIntoNest);
		break;

  }
  return;
}

//==========================================================================================================================================


//==========================================================================================================================================

// use T2 for wall avoid

// notes for next time
// have default behavior move back further and turn more?
// if it has an egg, keep small backing

task DetectWall()
{
  while(true)
  {
    wait1Msec(300);                                 // Allow for a short wait, freeing up the CPU for other tasks.

    //if (SensorValue(leftTouchSensor) == 1)
    if (TSreadState(LEGOTOUCHLEFT))
  	{
  		nxtDisplayCenteredBigTextLine(0, "TASK WALL");     // Display that Main is running.

  		if (isMovingTowardEgg)
  		{
  			StopTask(MoveTowardEgg);
  			isMovingTowardEgg = false;
  		}
  		StopTask(Wander);
  		StopTask(DetectEgg);

    	//leftTouchHit = true;
    	ClearTimer(T2);
    	while (time1[T2] < 300)
    	{
    		goBackward(CURRENT_SPEED);
    	}
    	ClearTimer(T2);
    	// turnRight
    	while (time1[T2] < 300)
    	{
    		turnRight(CURRENT_SPEED - 20);
    	}

    	wait1Msec(300);

    	StartTask(Wander, 1);
    	wait1Msec(1000);
    	StartTask(DetectEgg, 5);
    }
    //else if (SensorValue(rightTouchSensor) == 1)
    else if (TSreadState(LEGOTOUCHRIGHT))
    {
    	nxtDisplayCenteredBigTextLine(0, "TASK WALL");     // Display that Main is running.

    	if (isMovingTowardEgg)
  		{
  			StopTask(MoveTowardEgg);
  			isMovingTowardEgg = false;
  		}
    	StopTask(Wander);
  		StopTask(DetectEgg);

    	//rightTouchHit = true;
    	ClearTimer(T2);
    	while (time1[T2] < 300)
    	{
    		goBackward(CURRENT_SPEED);
    	}
    	ClearTimer(T2);
    	// turnLeft
    	while (time1[T2] < 300)
    	{
    		turnLeft(CURRENT_SPEED - 20);
    	}

    	wait1Msec(300);

    	StartTask(Wander, 1);
    	wait1Msec(1000);
    	StartTask(DetectEgg, 5);
    }
  }
  return;
}

//==========================================================================================================================================

//==========================================================================================================================================

// use T2 for wall avoid
task InNestWithoutEgg()
{
  while(true)
  {

    wait1Msec(300);                                 // Allow for a short wait, freeing up the CPU for other tasks.

		if (!goingToScore && (isOverTape(LSvalNorm(LEGOLS))))
		{

	    if ( (isInHomeRange(HTMCreadHeading(HTCOMPASS))) && !couldBeInEnemyNest )
	    {
	    	nxtDisplayCenteredBigTextLine(0, "TASK CORRECT");     // Display that Main is running.

	    	StopTask(Wander);
	  		StopTask(DetectEgg);

	  		// then back up into arena again
				ClearTimer(T4);
		  	// go backward a large distance
		  	while (time1[T4] < 2000)
		  	{
		  		goBackward(CURRENT_SPEED);
		  	}

		  	halt();

				wait1Msec(300);

				// then turn around and start detect egg again
				ClearTimer(T4);
		  	// turn until compass knows we're facing away from home
		  	while (!(isFacingOppositeHome(HTMCreadHeading(HTCOMPASS))))
		  	{
		  		turnLeft(CURRENT_SPEED);
		  	}

		  	halt();

				wait1Msec(300);

				/*
				// go forward a bit

				ClearTimer(T4);

		  	while (time1[T4] < 400)
		  	{
		  		goForward(CURRENT_SPEED);
		  	}

		  	halt();
		  	*/

				// then start detect egg task again, wander should still be going at this point

				EndTimeSlice();

				StartTask(DetectEgg, 5);
				StartTask(Wander, 1);
	  	}

	  	else
	  	{
	  		couldBeInEnemyNest = true;
	  	}
  	}
  	else
  	{
  		couldBeInEnemyNest = false;
  	}
  }
  return;
}

//====================================================================================================================================

bool isInHomeRange(int value)
{

	//if (value > 170 || value < -170)
	if (value > (HOME_TARGET - 50) && value < (HOME_TARGET + 50) )
	{
		return true;
	}
	else
		return false;
}

bool isOnHomeTarget(int value)
{
	//if (value > 310 && value < 320)
	if (value > (HOME_TARGET - 10) && value < (HOME_TARGET + 10) )
	{
		return true;
	}
	else
		return false;
}

bool isOverTape(int value)
{
	if (value < LIGHT_SENSOR_BLACK)
	{
		return true;
	}
	else
		return false;
}

bool isFacingOppositeHome(int value)
{
	//if (value > 170 || value < -170)
	if (value > 75 && value < 90)
	{
		return true;
	}
	else
		return false;
}

void armCheck()
{
	// reset arms
	if (nMotorEncoder[motorA] < ARMS_NORMAL)
	{
		while (nMotorEncoder[motorA] < ARMS_NORMAL)
  	{
  		motor[motorA] = 15;
  	}
  	motor[motorA] = 0;
	}
}

void turnLeft(int speed)
{
	motor[motorC] = 0;
	motor[motorB] = speed;
}

void turnRight(int speed)
{
	motor[motorC] = speed;
	motor[motorB] = 0;
}

void goForward(int speed)
{
	motor[motorC] = speed;
	motor[motorB] = speed;
}

void goBackward(int speed)
{
	motor[motorC] = -speed;
	motor[motorB] = -speed;
}

void halt()
{
	motor[motorC] = 0;
	motor[motorB] = 0;
}

void openArm(int speed)
{
	motor[motorA] = -speed;
}

void closeArm(int speed)
{
	motor[motorA] = speed;
}

void haltArm()
{
	motor[motorA] = 0;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

task main()
{
	// target value set for new north
	int _target = 0;

	// int value for norm light sensor display on screen
	int nrm = 0;

	// Turn the light on
  LSsetActive(LEGOLS);

	// wait for enter press to set "new north"
	while(nNxtButtonPressed != kEnterButton)
	{
		_target = HTMCsetTarget(HTCOMPASS);
	}

	// change current speed here
	CURRENT_SPEED = SPEED_60;

  StartTask(Wander, 1);                             // Start Task TOne.
  StartTask(DetectEgg, 5);                             // Start Task TTwo.
  StartTask(DetectWall, 11);
  //StartTask(InNestWithoutEgg, 10);

  while(true)
  {
    wait1Msec(300);                                 // Allow for a short wait, freeing up the CPU for other tasks.

    // get nrm value for display
		nrm = LSvalNorm(LEGOLS);


		nxtDisplayTextLine(4, "Abs:   %4d", HTMCreadHeading(HTCOMPASS));
    nxtDisplayTextLine(5, "Rel:   %4d", HTMCreadRelativeHeading(HTCOMPASS));
    nxtDisplayTextLine(6, "Norm: %4d", nrm);
  }
  return;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
